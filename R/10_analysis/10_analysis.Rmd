---
title: "10_analysis"
author: "Victor Yuan"
date: "April 21, 2019"
output:
  html_document:
    keep_md: true
    toc: true
    toc_depth: 4
    toc_float:
      collapsed: false
    theme: spacelab
editor_options: 
  chunk_output_type: console
---

This is for analysing the scRNAseq data
# 1.0 Libraries and Data

```{r}
library(readxl) # read data in
library(plyr) 
library(stringr)
library(knitr);library(kableExtra) # for displaying pretty tables
library(dplyr)
library(Seurat) # V3
library(readr)
library(ggplot2)
library(cowplot)
library(tidyr)
library(monocle)
library(slingshot)
library(RColorBrewer)
scobj_merge <- readRDS('../../data/interim/01_scobj_merge.rds')
```

# 2.0 Validate hits

First subset to trophoblast

## 2.1 Subset to Trophoblast Cells

From article:

"The trophoblast clusters (clusters 1, 9, 20, 13 and 16 from Fig. 1d) were taken from the initial analysis of all cells and merged with the enriched EPCAM+ and HLA-G+ cells. The droplet-based and Smart-seq2 datasets were integrated and clustered using the same workflow as described above. Only cells that were identified as trophoblast were considered for trajectory analysis."

So clusters 1, 9, 20, 13, and 16. And also EPCAM+ and HLA-G+ sortd cells.

```{r}
Idents(scobj_merge) <- 'final_cluster'
table(Idents(scobj_merge))

troph <- subset(scobj_merge, subset = final_cluster %in% c(1, 9, 20, 13, 16))
troph
table(Idents(troph))
table(troph$platform)

# assign cell type labels to clusters based on paper
troph$celltype <- ifelse(troph$final_cluster == 1, 'VCT',
                         ifelse(troph$final_cluster == 9, 'VCT p',
                                ifelse(troph$final_cluster == 16, 'EVT',
                                       ifelse(troph$final_cluster == 13, 'EVT p',
                                              ifelse(troph$final_cluster == 20, 'SCT', NA)))))
Idents(troph) <- 'celltype'
```

Recompute pca and umap coordinates on trophoblast cells:

```{r}
# find variable features
troph <- FindVariableFeatures(object = troph,
                              selection.method = "vst", 
                              nfeatures = 2000, 
                              verbose = T, assay = 'integrated')
#redo umap / pca
troph <- ScaleData(object = troph, verbose = FALSE)
troph <- RunPCA(object = troph, npcs = 10, verbose = FALSE)
troph <- RunUMAP(object = troph, reduction = "pca", 
    dims = 1:10)
DimPlot(object = troph, reduction = "umap", group.by = "celltype") + 
  theme_classic() +
  ggtitle('Trophoblast cells (n = 14366)')

DimPlot(object = troph, reduction = "pca", group.by = "celltype") + 
  theme_classic() +
  ggtitle('Trophoblast cells (n = 14366)')
DimPlot(object = troph, reduction = "pca", group.by = "celltype", dims = c(3,4)) + 
  theme_classic() +
  ggtitle('Trophoblast cells (n = 14366)')
```

then plot expression of hits

## 2.2 list of hits

### Violin plots

```{r}
hitlist <- read_xlsx('../../2019-03-19 currated scRNA-seq gene list.xlsx')
hitlist <- hitlist %>% gather(key = 'Geneset', value = 'Gene') %>% filter(!is.na(Gene))

# order levels to plot by
Idents(troph) <- factor(as.character(Idents(troph)), 
                        levels = c('VCT', 'VCT p', 'EVT', 'EVT p', 'SCT'))

#violin plots
VlnPlot(object = troph, features = hitlist$Gene[hitlist$Geneset=='Troph (general)'], 
        pt.size = F, ncol = 4, same.y.lims =  T) 
VlnPlot(object = troph, features = hitlist$Gene[hitlist$Geneset=='CTB'],
        pt.size = F, same.y.lims =  T)
VlnPlot(object = troph, features = hitlist$Gene[hitlist$Geneset=='Dist CCTB'], 
        pt.size = F, same.y.lims =  T)
VlnPlot(object = troph, features = hitlist$Gene[hitlist$Geneset=='Prox CCTB'],
        pt.size = F, same.y.lims =  T)
VlnPlot(object = troph, features = hitlist$Gene[hitlist$Geneset=='Syn Pre CTB'],
        pt.size = F, same.y.lims =  T)
VlnPlot(object = troph, features = hitlist$Gene[hitlist$Geneset=='Target High'],
        pt.size = F, same.y.lims =  T, ncol = 5)
VlnPlot(object = troph, features = hitlist$Gene[hitlist$Geneset=='Target Low'],
        pt.size = F, same.y.lims =  T, ncol = 5)
```

### heatmap

```{r}
#plot average expression
average_exp <- AverageExpression(object = troph, return.seurat = T)
ave_exp_mat <- average_exp@assays$integrated@scale.data[,] %>% as.data.frame()

library(pheatmap)
#create annotation dataframe for genes
row_label <- as.data.frame(hitlist) 
row_label$Gene <- make.unique(row_label$Gene)
rownames(row_label) <- gsub('\\.', '-', row_label$Gene)
row_label$Geneset <- factor(row_label$Geneset, 
                            levels = c('Troph (general)', 'CTB', 'Dist CCTB', 'Prox CCTB', 
                                       'Syn Pre CTB', 'Target High', 'Target Low'))

row_label <- row_label[intersect(rownames(row_label), rownames(ave_exp_mat)),]
ave_exp_mat <- ave_exp_mat[rownames(row_label),]
pheatmap(ave_exp_mat[,c('VCT', 'VCT p', 'EVT', 'EVT p', 'SCT')], 
         cluster_rows = F, cluster_cols = F, 
         annotation_row = row_label[,'Geneset',F],
         color = RColorBrewer::brewer.pal(9, "Blues"),
         cellwidth = 15, cellheight = 15)
```

# 3.0 Pseudotime

Note that because we are importing seurat merged data, we have to set the `expressionFamily` 
argument as 'gaussianff'. Then, in following functions, when possible we must specify the arguments
`norm_method` = 'none' and `pseudo_expr` = 0.

## 3.1 Import into monocle

```{r}
# import into monocle object
#Extract data, phenotype data, and feature data from the SeuratObject
troph_data <- as(as.matrix(troph@assays$integrated@data), 'sparseMatrix')

pd <- new('AnnotatedDataFrame', data = troph@meta.data)

fData <- data.frame(gene_short_name = row.names(troph_data), row.names = row.names(troph_data))
fd <- new('AnnotatedDataFrame', data = fData)

#Construct monocle object
monocle_cds <- newCellDataSet(troph_data,
                         phenoData = pd,
                         featureData = fd,
                         lowerDetectionLimit = 0.5,
                         expressionFamily = uninormal())

# process, not necessary unless using negbinomial 
#monocle_cds <- estimateSizeFactors(monocle_cds)
#monocle_cds <- estimateDispersions(monocle_cds) # not neessary for gaussian data

# remove genes with very low expression (noninformative)
#monocle_cds <- detectGenes(monocle_cds, min_expr = 0.1)

# sellect a minimum number of cells expressing a gene as a threshold
#fData(monocle_cds)$use_for_ordering <- 
#  fData(monocle_cds)$num_cells_expressed > 0.05 * ncol(monocle_cds)
```

## 3.2 Create trajectory

Here we try pseudotime analysis on the trophoblast cells using 3 different approaches to generate 
the trajectory.

### Ordering based on cluster DEGs

Here we are finding clusters on a reduced dimensional projection (PCA -> TSNE), then 
clustering ('density-peak'), then finding the top 1000 differentially expressed genes, then 
performing the pseudotime analysis on those genes. This is the recommended approach from the
documentation.

```{r}
# select number of principal components to use for pseudotime
plot_pc_variance_explained(cds = monocle_cds, max_components = 25â†“, return_all = F, 
                           pseudo_expr = 0, norm_method = 'none') # required argumnets for gaussianff
monocle_cds <- reduceDimension(monocle_cds, max_components = 2, 
                               norm_method = 'none', pseudo_expr = 0,
                               num_dim = 10, reduction_method = 'tSNE', verbose = T)

# run density peak clustering on reduced projection
monocle_cds <- clusterCells(monocle_cds, rho_threshold = 2,
                         delta_threshold = 5,
                         skip_rho_sigma = T,
                         verbose = F)

#  this plot can help us decide number of clusters
plot_rho_delta(monocle_cds, rho_threshold = 2, delta_threshold = 5)

plot_cell_clusters(monocle_cds, color_by = 'as.factor(Cluster)')
plot_cell_clusters(monocle_cds, color_by = 'as.factor(celltype)')
```

Run DEG on clusters

~45 minutes with 24 cores

```{r eval = F}
# find differentially expressed genes between all clusters
clustering_DEG_genes <- differentialGeneTest(monocle_cds,
                                             fullModelFormulaStr = '~Cluster',
                                             cores = 24)
```

saveRDS(clustering_DEG_genes, '../../data/interim/clustering_DEG_genes.rds')

```{r}
clustering_DEG_genes <- readRDS('../../data/interim/clustering_DEG_genes.rds')

# select top 1000 differnetially expressed genes to order the cells
ordering_genes <- row.names(clustering_DEG_genes)[order(clustering_DEG_genes$qval)][1:1000]
monocle_cds <- setOrderingFilter(monocle_cds, ordering_genes = ordering_genes)
monocle_cds <- reduceDimension(monocle_cds, method = 'DDRTree', 
                               norm_method = 'none', pseudo_expr = 0)
monocle_cds <- orderCells(monocle_cds)
plot_cell_trajectory(monocle_cds, color_by = "as.factor(celltype)")
```

Pretty good, but it's strange that proliferative EVT's are simply on the other side of the branch point.

### Based on top 1000 variable genes

```{r, eval = F}
top1000variable <- troph@assays$integrated@var.features[1:1000]
monocle_cds <- setOrderingFilter(monocle_cds, ordering_genes = top1000variable)
monocle_cds <- reduceDimension(monocle_cds, method = 'DDRTree',
                               norm_method = 'none', pseudo_expr = 0)
monocle_cds <- orderCells(monocle_cds)
plot_cell_trajectory(monocle_cds, color_by = "as.factor(celltype)")

plot_cell_trajectory(monocle_cds, color_by = "Pseudotime")

```

Plotting

```{r}
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'CTB') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Prox CCTB') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Dist CCTB') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Syn Pre CTB') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Target High') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Target Low') %>% pull(Gene))

plot_genes_in_pseudotime(monocle_cds[hitlist %>% filter(Geneset == 'CTB') %>% pull(Gene),],
                         relative_expr = F, color_by = 'celltype')
```

This looks pree good. Can it be better?

### Based on top 1000 DEGs between all trophoblast subtypes

```{r eval = F}
# find differentially expressed genes between trophoblasts
troph_DEG_genes <- differentialGeneTest(monocle_cds,
                                        fullModelFormulaStr = '~celltype',
                                        cores = 24)
```

saveRDS(troph_DEG_genes, '../../data/interim/troph_DEG_genes.rds')

```{r}
troph_DEG_genes <- readRDS('../../data/interim/troph_DEG_genes.rds')

ordering_genes <- row.names(troph_DEG_genes)[order(troph_DEG_genes$qval)][1:1000]
monocle_cds <- setOrderingFilter(monocle_cds, ordering_genes = ordering_genes)
monocle_cds <- reduceDimension(monocle_cds, method = 'DDRTree', 
                               norm_method = 'none', pseudo_expr = 0)
monocle_cds <- orderCells(monocle_cds)
plot_cell_trajectory(monocle_cds, color_by = "as.factor(celltype)")

```

Best so far

### Based on all genes

Takes > 12 hours, will omit for now.

```{r eval = F}
troph_expressed_genes <- rownames(troph)[Matrix::rowMeans(troph@assays$RNA@counts) > 0.1]
length(troph_expressed_genes) # 10491

ordering_genes <- troph_expressed_genes
monocle_cds <- setOrderingFilter(monocle_cds, ordering_genes = ordering_genes)
monocle_cds <- reduceDimension(monocle_cds, method = 'DDRTree', 
                               norm_method = 'none', pseudo_expr = 0)
monocle_cds <- orderCells(monocle_cds)
plot_cell_trajectory(monocle_cds, color_by = "as.factor(celltype)")
```

### Based on trophoblast marker genes.

First we assign cell type by trophoblast marker genes

```{r}
EGFR_id <- row.names(subset(fData(monocle_cds), gene_short_name == "EGFR"))
HLAG_id <- row.names(subset(fData(monocle_cds), gene_short_name == "HLA-G"))
ENDOU_id <- row.names(subset(fData(monocle_cds), gene_short_name == "ENDOU"))
MKI67_id <- row.names(subset(fData(monocle_cds), gene_short_name == "MKI67"))
  

cth <- newCellTypeHierarchy()

cth <- addCellType(cth,
                   cell_type_name = "CTB",
                   classify_func = function(x) { x[EGFR_id,] >= 0.1 })

cth <- addCellType(cth,
                   cell_type_name = "CTB p", parent_cell_type_name = "CTB",
                   classify_func = function(x) { x[MKI67_id,] >= 0.1 })

cth <- addCellType(cth,
                   cell_type_name = "EVT",
                   classify_func = function(x) { x[HLAG_id,] >= 0.1 })

cth <- addCellType(cth,
                   cell_type_name = "EVT p", parent_cell_type_name = "EVT",
                   classify_func = function(x) { x[MKI67_id,] >= 0.1 })

cth <- addCellType(cth,
                   cell_type_name = "STB",
                   classify_func = function(x) { x[ENDOU_id,] >= 0.1})

monocle_cds <- classifyCells(monocle_cds, cth)
```

Now we select additional genes that covary with these marker genes

```{r}
# do this on only the genes with expression over a minimum value
troph_expressed_genes <- rownames(troph)[Matrix::rowMeans(troph@assays$RNA@counts) > 0.1]
length(troph_expressed_genes) # 10491

# find expressed genes
marker_diff <- markerDiffTable(monocle_cds[,],
                               cth, cores = 24)
semisup_clustering_genes <-
    row.names(subset(marker_diff, qval < 0.05))
semisup_clustering_genes <-
    row.names(marker_diff)[order(marker_diff$qval)][1:1000]
```

```{r}
monocle_cds <- setOrderingFilter(monocle_cds, semisup_clustering_genes)
monocle_cds <- reduceDimension(monocle_cds, max_components = 2,
    method = 'DDRTree', norm_method = 'none', pseudo_expr = 0)
monocle_cds <- orderCells(monocle_cds)
plot_cell_trajectory(monocle_cds, color_by = "celltype") +
    theme(legend.position = "right")
```

## 3.3 Plot gene expression along trajectory

```{r}
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'CTB') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Prox CCTB') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Dist CCTB') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Syn Pre CTB') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Target High') %>% pull(Gene))
plot_cell_trajectory(monocle_cds, use_color_gradient = TRUE, cell_size = 1, markers_linear = T,
                     markers = hitlist %>% filter(Geneset == 'Target Low') %>% pull(Gene))
```

## 3.4 Slingshot

Here I try Slingshot because it can take a reduced dimensional matrix of the cells

```{r}
sce <- slingshot(data = troph@reductions$umap@cell.embeddings, 
                 clusterLabels = troph$celltype)




line <- getLineages(troph@reductions$umap@cell.embeddings, 
                    clusterLabels = troph$celltype, 
                    start.clus = 'VCT')
crv1 <- getCurves(line)

plot(troph@reductions$umap@cell.embeddings[,1:2], 
     col = brewer.pal(9,"Set1")[as.numeric(as.factor(troph$celltype))], asp = 1, pch = 16)
lines(line, lwd = 3, col = 'black')

plot(troph@reductions$umap@cell.embeddings[,1:2], 
     col = brewer.pal(9,"Set1")[as.numeric(as.factor(troph$celltype))], asp = 1, pch = 16)
lines(crv1, lwd = 3, col = 'black')

pDat <- troph@meta.data %>% 
  as_tibble %>% 
  bind_cols(as_tibble(sce@reducedDim)) %>% 
  bind_cols(as_tibble(troph@reductions$umap@cell.embeddings)) %>%
  mutate(pseudotime = slingPseudotime(sce)[,1])

ggplot(pDat, aes(x = UMAP_1, y = UMAP_2, col = pseudotime)) +
  geom_point()
ggplot(pDat, aes(x = celltype, y = pseudotime, col = celltype)) +
  geom_boxplot()
```